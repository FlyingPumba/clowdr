# Urql Cache Generic Resolver for Hasura GraphQL APIs

This package provides generic resolver and updater classes for Urql's cache to
handle Hasura queries and mutations.

This relies upon the augmented GraphQL schema generated by the companion package
`urql-hasura-cache-schema-generator`. You should use that package to generate
your augmented schema before setting up this package.

## How to use

1. Install this package in your frontend
1. TODO: Setup instructions

## Resolving queries: How it works

The aim is to produce generic classes that can be provided to the Urql Cache
`resolvers` and `updaters` options. Most of this explanation focuses on
`resolvers`, with `updater`-specific logic explained at the end.

Resolvers effectively execute a database query against a client-side datastore.
They're mirroring the logic of the server-side database except the available
client-side data may be partially available or not available at all.

Our goal is to create a resolver that implements the same query logic as Hasura.
The resolver must navigate all available cached data (ignoring extraneous
information such as the where-clauses used to look up the data). The augmented
GQL schema generator provides us the relationship keying information necessary
to navigate lookups across tables.

### Understanding resolver types

Our first task is to address the structure of `resolvers`.

Urql cache specifies the following types for a resolver function (with a few
simplifications where it aids understanding without fundamentally changing the
type):

```ts
import { TypedDocumentNode } from "@urql/core";
import { GraphQLError, DocumentNode, FragmentDefinitionNode } from "graphql";

// Utility type for "array of nulls or T"
type NullArray<T> = Array<null | T | NullArray<T>>;

// A primitive (TypeScript) type.
// N.B. Does not include undefined.
type Primitive = null | number | boolean | string;

// Scalar objects are objects that are not from entities
// e.g. a JSON field will return a JSON blob which will be parsed into a scalar object
interface ScalarObject {
  constructor?: Function;
  [key: string]: any;
}

type Scalar = Primitive | ScalarObject;

// A data field is either a scalar value or a non-empty entity (`Data`) or an array of these.
type DataField = Scalar | Data | NullArray<Scalar> | NullArray<Data>;

// System fields are the fields which receive special treatment by the cache.
// `__typename` is required for all entities (Urql takes care of making sure it is always requested).
// `_id` and `id` are the special cases where Urql cache treats them as primary keys automatically.
interface SystemFields {
  __typename: string;
  _id?: string | number | null;
  id?: string | number | null;
}
// Fields of an entity -- conceptually it's: `Record<string, DataField>`
interface DataFields {
  [fieldName: string]: DataField;
}
// A non-empty, concrete entity
// * Non-empty meaning it cannot be null/undefined
// * Concrete meaning the data is provided, it's not just a string-like reference to the entity in the cache
type Data = SystemFields & DataFields;

// An entity - null, concrete or referential
//     N.B. this type isn't used in the definitions below but has been left for context/understanding
type Entity = null | Data | string;

// Variables in the GQL sense - i.e. inputs to an operation
interface Variables {
  [name: string]: Scalar | Scalar[] | Variables | NullArray<Variables>;
}

interface Fragments {
  [fragmentName: string]: void | FragmentDefinitionNode;
}
// [Refer to Urql API documentation](https://formidable.com/open-source/urql/docs/api/graphcache/#info)
interface ResolveInfo {
  parent: Data;
  parentTypeName: string;
  parentKey: string;
  parentFieldKey: string;
  fieldName: string;
  fragments: Fragments;
  variables: Variables;
  error: GraphQLError | undefined;
  partial?: boolean;
  optimistic?: boolean;
  __internal?: unknown;
}

// The result of resolving can be a concrete non-empty entity or nothing.
//    The type is rather confusing. In practice it is allowing:
//        null | undefined | Scalar | Data | NullArray<Scalar> | NullArray<Data>
//
//    Except `Data` has been weakened to make `__typename` optional
//    (as will most often be the case, the caller may not have requested the `__typename` field)
type ResolverResult =
  | DataField
  | (DataFields & {
      __typename?: string;
    })
  | null
  | undefined;

// Finally, the thing we wanted to understand!
//     N.B. The type has been simplified to remove the generic arguments so we can understand it a little more easily
type Resolver = (parent: DataFields, args: Variables, cache: Cache, info: ResolveInfo) => ResolverResult;
```

So a `resolver` is a function that takes a parent context (some slice of the
cache data), some arguments (variable map), a reference to the cache instance
and some "resolve info" - the information that tells us what we're supposed to
be resolving - and returns the scalar or entity or nothing.

We see from our generated GraphQL type definitions that Urql's cache has the
following configuration types:

```ts
type GraphCacheConfig = {
  schema?: IntrospectionData;
  updates?: GraphCacheUpdaters;
  keys?: GraphCacheKeysConfig;
  optimistic?: GraphCacheOptimisticUpdaters;
  resolvers?: GraphCacheResolvers;
  storage?: GraphCacheStorageAdapter;
};
```

Let's take a small sample of the `GraphCacheResolvers` type:

```ts
type GraphCacheResolvers = {
  query_root?: {
    Email?: GraphCacheResolver<WithTypename<Query_Root>, Query_RootEmailArgs, Array<WithTypename<Email> | string>>;
    Email_aggregate?: GraphCacheResolver<
      WithTypename<Query_Root>,
      Query_RootEmail_AggregateArgs,
      WithTypename<Email_Aggregate> | string
    >;
    Email_by_pk?: GraphCacheResolver<WithTypename<Query_Root>, Query_RootEmail_By_PkArgs, WithTypename<Email> | string>;

    /* ... */
  };

  /* ... */

  Email?: {
    /* Sample of fields, not all of them... */
    id?: GraphCacheResolver<WithTypename<Email>, Record<string, never>, Scalars["uuid"] | string>;
    invitation?: GraphCacheResolver<
      WithTypename<Email>,
      Record<string, never>,
      WithTypename<Registrant_Invitation> | string
    >;
    invitationId?: GraphCacheResolver<WithTypename<Email>, Record<string, never>, Scalars["uuid"] | string>;
    retriesCount?: GraphCacheResolver<WithTypename<Email>, Record<string, never>, Scalars["Int"] | string>;
    updatedAt?: GraphCacheResolver<WithTypename<Email>, Record<string, never>, Scalars["timestamptz"] | string>;
    user?: GraphCacheResolver<WithTypename<Email>, Record<string, never>, WithTypename<User> | string>;
    userId?: GraphCacheResolver<WithTypename<Email>, Record<string, never>, Scalars["String"] | string>;
  };
  Email_aggregate?: {
    aggregate?: GraphCacheResolver<
      WithTypename<Email_Aggregate>,
      Record<string, never>,
      WithTypename<Email_Aggregate_Fields> | string
    >;
    nodes?: GraphCacheResolver<
      WithTypename<Email_Aggregate>,
      Record<string, never>,
      Array<WithTypename<Email> | string>
    >;
  };
  Email_aggregate_fields?: {
    max?: GraphCacheResolver<
      WithTypename<Email_Aggregate_Fields>,
      Record<string, never>,
      WithTypename<Email_Max_Fields> | string
    >;
    stddev?: GraphCacheResolver<
      WithTypename<Email_Aggregate_Fields>,
      Record<string, never>,
      WithTypename<Email_Stddev_Fields> | string
    >;
    stddev_pop?: GraphCacheResolver<
      WithTypename<Email_Aggregate_Fields>,
      Record<string, never>,
      WithTypename<Email_Stddev_Pop_Fields> | string
    >;
    stddev_samp?: GraphCacheResolver<
      WithTypename<Email_Aggregate_Fields>,
      Record<string, never>,
      WithTypename<Email_Stddev_Samp_Fields> | string
    >;
    sum?: GraphCacheResolver<
      WithTypename<Email_Aggregate_Fields>,
      Record<string, never>,
      WithTypename<Email_Sum_Fields> | string
    >;
  };
  Email_max_fields?: {
    id?: GraphCacheResolver<WithTypename<Email_Max_Fields>, Record<string, never>, Scalars["uuid"] | string>;
    invitationId?: GraphCacheResolver<WithTypename<Email_Max_Fields>, Record<string, never>, Scalars["uuid"] | string>;
    retriesCount?: GraphCacheResolver<WithTypename<Email_Max_Fields>, Record<string, never>, Scalars["Int"] | string>;
    updatedAt?: GraphCacheResolver<
      WithTypename<Email_Max_Fields>,
      Record<string, never>,
      Scalars["timestamptz"] | string
    >;
    userId?: GraphCacheResolver<WithTypename<Email_Max_Fields>, Record<string, never>, Scalars["String"] | string>;
  };
  Email_stddev_fields?: {
    retriesCount?: GraphCacheResolver<
      WithTypename<Email_Stddev_Fields>,
      Record<string, never>,
      Scalars["Float"] | string
    >;
  };
  Email_stddev_pop_fields?: {
    retriesCount?: GraphCacheResolver<
      WithTypename<Email_Stddev_Pop_Fields>,
      Record<string, never>,
      Scalars["Float"] | string
    >;
  };
  Email_stddev_samp_fields?: {
    retriesCount?: GraphCacheResolver<
      WithTypename<Email_Stddev_Samp_Fields>,
      Record<string, never>,
      Scalars["Float"] | string
    >;
  };
  Email_sum_fields?: {
    retriesCount?: GraphCacheResolver<WithTypename<Email_Sum_Fields>, Record<string, never>, Scalars["Int"] | string>;
  };

  Email_mutation_response?: {
    affected_rows?: GraphCacheResolver<
      WithTypename<Email_Mutation_Response>,
      Record<string, never>,
      Scalars["Int"] | string
    >;
    returning?: GraphCacheResolver<
      WithTypename<Email_Mutation_Response>,
      Record<string, never>,
      Array<WithTypename<Email> | string>
    >;
  };

  /* ... */
};
```

Oof. That doesn't feel small but it's tiny compared to our full schema. It
contains a useful sampling of everything we're going to encounter. Now let's try
to break it down.

`resolvers.query_root` is the root of all data in the cache that was returned by
a query. If you've worked with non-Hasura GQL APIs in the past you may have
found this named `Query` or similar. These functions resolve complete entities.

The contents of the query root are the tables and aggregations we're used to
querying when we write a GQL query. These will be the main entry points for our
resolver function. When someone queries the `Email`s table, the
`query_root.Email` resolver is called.

What about all these things outside of the `query_root`? The
`resolvers.query_root.Email` tells the cache how to resolve an entire `Email`
entity. The `resolvers.Email` tells the cache how to resolve individual fields
within an `Email` entity. It allows us to override the resolution of a
particular field. For scalar fields, we're not going to do anything special. But
for relational fields (such as `user`), our generic resolver is going to
intervene to perform the lookup across the whole cache in addition to any data
nested within the `Email` entity (which may be present if the `Email.user` was
fetched without the `User` primary key field).

Armed with this knowledge, the rest of our sample is trivial. Each field is
allowing us the opportunity to override how to look up (i.e. resolve) the
corresponding field within the respective entity. The thing to bear in mind is
entities within the GQL API are more than just the entities in your database -
e.g. aggregations, mutation responses, etc.

### Handling the resolvers we care about

Okay, there's a bunch of stuff in this tree and some of it we need our generic
resolver to handle (anything that's looking up an entity over a
foreign-key-style relationship) and the rest we need to ignore to allow the
cache to operate its default implementation.

We need to be able to do this without knowing the names of what we're handling -
we'd rather have a single short implementation for everything than try to
generate hundreds of thounsands of lines of repetitive code.

This is where EcmaScript's
[Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
type comes in!

Using proxies we can look at the name of the function being called or property
being accessed and decide whether to handle the call or not. The handler
functions of interest to use are `apply`, `get`, `has`.

We're also going to accept a custom object for developers to provide manual
resolvers for bits of the API that our generic resolver doesn't understand (e.g.
Hasura Actions).

### Selecting what to resolve

N.B. Urql knows nothing about aggregation queries so we need to provide
resolvers for them.

1. Check the custom resolvers first
   - This needs to be a deep resolution not a shallow lookup
1. Anything within the `query_root` (including aggregations)
1. Relational fields within table-like entities where our augmented schema
   contains the information for how to look up the relation.
1. `aggregate` and `nodes` fields of aggregation queries
1. Fields of any of the aggregation operators

### Custom resolvers lookup

- TODO: Document this

### Resolving query_root entities

- TODO: Check available cache data for the exact query key first, then merge with other available data
- TODO: Document this

### Resolving relational fields

- TODO: Check available cache data for the field within the object first, then merge with other available data
- TODO: Document this

### Resolving `aggregate` and `nodes` fields

- TODO: Check available cache data for the exact query key first, then merge with other available data
- TODO: Document this

### Resolving aggregation operators

- TODO: Check available cache data for the exact query key first, then merge with other available data
- TODO: Document this

## Resolving updates: How it works

- TODO: Check manual updates first
- TODO: Handle deletions (these are the only updates we care about)
  - Including manually deleting from nested array fields if necessary? Does the cache already do this for us if we evict an entity?
